namespace Glidergun;

public static class GridCore
{
    private static readonly ArcPyNet._SpatialAnalyst sa = ArcPyNet.ArcPy.Instance.sa;

    public static Grid Con(this Grid raster1, Grid raster2, Grid raster3) => sa.Con(raster1, raster2, raster3);
    public static Grid Con(this Grid raster1, Grid raster2, int n) => sa.Con(raster1, raster2, n);
    public static Grid Con(this Grid raster1, Grid raster2, double n) => sa.Con(raster1, raster2, n);
    public static Grid Con(this Grid raster1, int n, Grid raster2) => sa.Con(raster1, n, raster2);
    public static Grid Con(this Grid raster1, double n, Grid raster2) => sa.Con(raster1, n, raster2);
    public static Grid Con(this Grid raster, int n1, int n2) => sa.Con(raster, n1, n2);
    public static Grid Con(this Grid raster, double n1, double n2) => sa.Con(raster, n1, n2);
    public static Grid Pick(this Grid raster, params Grid[] rasters) => sa.Pick(raster, rasters);
    public static Grid SetNull(this Grid raster1, Grid raster2) => sa.SetNull(raster1, raster2);
    public static Grid SetNull(this Grid raster, int n) => sa.SetNull(raster, n);
    public static Grid SetNull(this Grid raster, double n) => sa.SetNull(raster, n);
    public static Grid SetNull(this Grid raster1, Grid raster2, string whereClause) => sa.SetNull(raster1, raster2, whereClause);
    public static Grid SetNull(this Grid raster, int n, string whereClause) => sa.SetNull(raster, n, whereClause);
    public static Grid SetNull(this Grid raster, double n, string whereClause) => sa.SetNull(raster, n, whereClause);
    public static Grid Corridor(this Grid inDistanceRaster1, Grid inDistanceRaster2) => sa.Corridor(inDistanceRaster1, inDistanceRaster2);
    public static Grid CostAllocation(this Grid inSourceData, Grid inCostRaster, double? maximumDistance = null, Grid? inValueGrid = null, string? sourceField = null, Grid? outDistanceGrid = null, Grid? outBacklinkGrid = null, double sourceCostMultiplier = 1, double sourceStartCost = 0, double sourceResistanceRate = 0, double? sourceCapacity = null, SourceDirection sourceDirection = SourceDirection.FromSource) => sa.CostAllocation(inSourceData, inCostRaster, maximumDistance, inValueGrid, sourceField, outDistanceGrid, outBacklinkGrid, sourceCostMultiplier, sourceStartCost, sourceResistanceRate, sourceCapacity, sourceDirection);
    public static Grid CostBackLink(this Grid inSourceData, Grid inCostRaster, double? maximumDistance = null, Grid? outDistanceGrid = null, double sourceCostMultiplier = 1, double sourceStartCost = 0, double sourceResistanceRate = 0, double? sourceCapacity = null, SourceDirection sourceDirection = SourceDirection.FromSource) => sa.CostBackLink(inSourceData, inCostRaster, maximumDistance, outDistanceGrid, sourceCostMultiplier, sourceStartCost, sourceResistanceRate, sourceCapacity, sourceDirection);
    public static Grid CostDistance(this Grid inSourceData, Grid inCostRaster, double? maximumDistance = null, Grid? outBacklinkGrid = null, double sourceCostMultiplier = 1, double sourceStartCost = 0, double sourceResistanceRate = 0, double? sourceCapacity = null, SourceDirection sourceDirection = SourceDirection.FromSource) => sa.CostDistance(inSourceData, inCostRaster, maximumDistance, outBacklinkGrid, sourceCostMultiplier, sourceStartCost, sourceResistanceRate, sourceCapacity, sourceDirection);
    public static Grid CostPath(this Grid inDestinationData, Grid inCostDistanceRaster, Grid inCostBacklinkRaster, string? pathType = null, string? destinationField = null, bool? forceFlowDirectionConvention = null) => sa.CostPath(inDestinationData, inCostDistanceRaster, inCostBacklinkRaster, pathType, destinationField, forceFlowDirectionConvention);
    public static Grid EucAllocation(this Grid inSourceData, double? maximumDistance = null, Grid? inValueGrid = null, double? cellSize = null, string? sourceField = null, Grid? outDistanceGrid = null, Grid? outDirectionGrid = null, string? distanceMethod = null, Grid? inBarrierData = null) => sa.EucAllocation(inSourceData, maximumDistance, inValueGrid, cellSize, sourceField, outDistanceGrid, outDirectionGrid, distanceMethod, inBarrierData);
    public static Grid EucBackDirection(this Grid inSourceData, Grid? inBarrierData = null, double? maximumDistance = null, double? cellSize = null, string? distanceMethod = null) => sa.EucBackDirection(inSourceData, inBarrierData, maximumDistance, cellSize, distanceMethod);
    public static Grid EucDirection(this Grid inSourceData, double? maximumDistance = null, double? cellSize = null, Grid? outDistanceGrid = null, string? distanceMethod = null, Grid? inBarrierData = null, Grid? outBackDirectionGrid = null) => sa.EucDirection(inSourceData, maximumDistance, cellSize, outDistanceGrid, distanceMethod, inBarrierData, outBackDirectionGrid);
    public static Grid EucDistance(this Grid inSourceData, double? maximumDistance = null, double? cellSize = null, Grid? outDirectionGrid = null, string? distanceMethod = null, Grid? inBarrierData = null, Grid? outBackDirectionGrid = null) => sa.EucDistance(inSourceData, maximumDistance, cellSize, outDirectionGrid, distanceMethod, inBarrierData, outBackDirectionGrid);
    public static Grid ExtractByAttributes(this Grid inRaster, string whereClause) => sa.ExtractByAttributes(inRaster, whereClause);
    public static Grid ExtractByCircle(this Grid inRaster, (double x, double y) centerPoint, double radius, ExtractionArea extractionArea = ExtractionArea.Inside) => sa.ExtractByCircle(inRaster, centerPoint, radius, extractionArea);
    public static Grid ExtractByMask(this Grid inRaster, Grid inMaskData) => sa.ExtractByMask(inRaster, inMaskData);
    public static Grid ExtractByPoints(this Grid inRaster, (double x, double y)[] points, ExtractionArea extractionArea = ExtractionArea.Inside) => sa.ExtractByPoints(inRaster, points, extractionArea);
    public static Grid ExtractByPolygon(this Grid inRaster, (double x, double y)[] points, ExtractionArea extractionArea = ExtractionArea.Inside) => sa.ExtractByPolygon(inRaster, points, extractionArea);
    public static Grid ExtractByRectangle(this Grid inRaster, Extent extent, ExtractionArea extractionArea = ExtractionArea.Inside) => sa.ExtractByRectangle(inRaster, extent, extractionArea);
    public static Grid Aggregate(this Grid inRaster, int cellFactor, AggregationType aggregationType = AggregationType.Sum, ExtentHandling extentHandling = ExtentHandling.Expand, MissingValues ignoreNodata = MissingValues.Data) => sa.Aggregate(inRaster, cellFactor, aggregationType, extentHandling, ignoreNodata);
    public static Grid BoundaryClean(this Grid inRaster, string? sortType = null, bool? numberOfRuns = null) => sa.BoundaryClean(inRaster, sortType, numberOfRuns);
    public static Grid Expand(this Grid inRaster, int numberCells, params int[] zoneValues) => sa.Expand(inRaster, numberCells, zoneValues);
    public static Grid MajorityFilter(this Grid inRaster, string? numberNeighbors = null, FilePath? majorityDefinition = null) => sa.MajorityFilter(inRaster, numberNeighbors, majorityDefinition);
    public static Grid Nibble(this Grid inRaster, Grid inMaskRaster, bool? nibbleValues = null, bool? nibbleNodata = null, Grid? inZoneGrid = null) => sa.Nibble(inRaster, inMaskRaster, nibbleValues, nibbleNodata, inZoneGrid);
    public static Grid RegionGroup(this Grid inRaster, NumberNeighbors numberNeighbors = NumberNeighbors.Four, ZoneConnectivity zoneConnectivity = ZoneConnectivity.Within, AddLink addLink = AddLink.AddLink, int? excludedValue = null) => sa.RegionGroup(inRaster, numberNeighbors, zoneConnectivity, addLink, excludedValue);
    public static Grid Shrink(this Grid inRaster, int numberCells, params int[] zoneValues) => sa.Shrink(inRaster, numberCells, zoneValues);
    public static Grid Thin(this Grid inRaster, string? backgroundValue = null, bool? filter = null, string? corners = null, double? maximumThickness = null) => sa.Thin(inRaster, backgroundValue, filter, corners, maximumThickness);
    public static Grid DarcyFlow(this Grid inHeadRaster, Grid inPorosityRaster, Grid inThicknessRaster, Grid inTransmissivityRaster, Grid? outDirectionGrid = null, Grid? outMagnitudeGrid = null) => sa.DarcyFlow(inHeadRaster, inPorosityRaster, inThicknessRaster, inTransmissivityRaster, outDirectionGrid, outMagnitudeGrid);
    public static Grid DarcyVelocity(this Grid inHeadRaster, Grid inPorosityRaster, Grid inThicknessRaster, Grid inTransmissivityRaster, Grid outMagnitudeGrid) => sa.DarcyVelocity(inHeadRaster, inPorosityRaster, inThicknessRaster, inTransmissivityRaster, outMagnitudeGrid);
    public static Grid Fill(this Grid inSurfaceRaster, double? zLimit = null) => sa.Fill(inSurfaceRaster, zLimit);
    public static Grid FlowAccumulation(this Grid inFlowDirectionGrid, Grid? inWeightGrid = null, string? dataType = null, string? flowDirectionType = null) => sa.FlowAccumulation(inFlowDirectionGrid, inWeightGrid, dataType, flowDirectionType);
    public static Grid FlowDirection(this Grid inSurfaceRaster, bool? forceFlow = null, Grid? outDropGrid = null, string? flowDirectionType = null) => sa.FlowDirection(inSurfaceRaster, forceFlow, outDropGrid, flowDirectionType);
    public static Grid FlowDistance(this Grid inStreamRaster, Grid inSurfaceRaster, Grid? inFlowDirectionGrid = null, string? distanceType = null, string? flowDirectionType = null, string? statisticsType = null) => sa.FlowDistance(inStreamRaster, inSurfaceRaster, inFlowDirectionGrid, distanceType, flowDirectionType, statisticsType);
    public static Grid FlowLength(this Grid inFlowDirectionGrid, string? directionMeasurement = null, Grid? inWeightGrid = null) => sa.FlowLength(inFlowDirectionGrid, directionMeasurement, inWeightGrid);
    public static Grid Sink(this Grid inFlowDirectionGrid) => sa.Sink(inFlowDirectionGrid);
    public static Grid SnapPourPoint(this Grid inPourPointData, Grid inAccumulationRaster, double snapDistance, string? pourPointField = null) => sa.SnapPourPoint(inPourPointData, inAccumulationRaster, snapDistance, pourPointField);
    public static Grid StreamLink(this Grid inStreamRaster, Grid inFlowDirectionGrid) => sa.StreamLink(inStreamRaster, inFlowDirectionGrid);
    public static Grid StreamOrder(this Grid inStreamRaster, Grid inFlowDirectionGrid, string? orderMethod = null) => sa.StreamOrder(inStreamRaster, inFlowDirectionGrid, orderMethod);
    public static Grid Watershed(this Grid inFlowDirectionGrid, Grid inPourPointData) => sa.Watershed(inFlowDirectionGrid, inPourPointData);
    public static Grid Watershed(this Grid inFlowDirectionGrid, FilePath inPourPointData, string pourPointField) => sa.Watershed(inFlowDirectionGrid, inPourPointData, pourPointField);
    public static Grid EqualToFrequency(this Grid inValueGrid, params Grid[] inRasters) => sa.EqualToFrequency(inValueGrid, inRasters);
    public static Grid GreaterThanFrequency(this Grid inValueGrid, params Grid[] inRasters) => sa.GreaterThanFrequency(inValueGrid, inRasters);
    public static Grid LessThanFrequency(this Grid inValueGrid, params Grid[] inRasters) => sa.LessThanFrequency(inValueGrid, inRasters);
    public static Grid Popularity(this Grid inPopularityRasterOrConstant, params Grid[] inRasters) => sa.Popularity(inPopularityRasterOrConstant, inRasters);
    public static Grid Rank(this Grid inRankRasterOrConstant, params Grid[] inRasters) => sa.Rank(inRankRasterOrConstant, inRasters);
    public static Grid Abs(this Grid raster) => sa.Abs(raster);
    public static Grid Divide(this Grid raster1, Grid raster2) => sa.Divide(raster1, raster2);
    public static Grid Divide(this Grid raster, int n) => sa.Divide(raster, n);
    public static Grid Divide(this Grid raster, double n) => sa.Divide(raster, n);
    public static Grid Exp(this Grid raster) => sa.Exp(raster);
    public static Grid Exp10(this Grid raster) => sa.Exp10(raster);
    public static Grid Exp2(this Grid raster) => sa.Exp2(raster);
    public static Grid Float(this Grid raster) => sa.Float(raster);
    public static Grid Int(this Grid raster) => sa.Int(raster);
    public static Grid Ln(this Grid raster) => sa.Ln(raster);
    public static Grid Log10(this Grid raster) => sa.Log10(raster);
    public static Grid Log2(this Grid raster) => sa.Log2(raster);
    public static Grid Minus(this Grid raster1, Grid raster2) => sa.Minus(raster1, raster2);
    public static Grid Minus(this Grid raster, int n) => sa.Minus(raster, n);
    public static Grid Minus(this Grid raster, double n) => sa.Minus(raster, n);
    public static Grid Mod(this Grid raster1, Grid raster2) => sa.Mod(raster1, raster2);
    public static Grid Mod(this Grid raster, int n) => sa.Mod(raster, n);
    public static Grid Mod(this Grid raster, double n) => sa.Mod(raster, n);
    public static Grid Negate(this Grid raster) => sa.Negate(raster);
    public static Grid Plus(this Grid raster1, Grid raster2) => sa.Plus(raster1, raster2);
    public static Grid Plus(this Grid raster, int n) => sa.Plus(raster, n);
    public static Grid Plus(this Grid raster, double n) => sa.Plus(raster, n);
    public static Grid Power(this Grid raster1, Grid raster2) => sa.Power(raster1, raster2);
    public static Grid Power(this Grid raster, int n) => sa.Power(raster, n);
    public static Grid Power(this Grid raster, double n) => sa.Power(raster, n);
    public static Grid RoundDown(this Grid raster) => sa.RoundDown(raster);
    public static Grid RoundUp(this Grid raster) => sa.RoundUp(raster);
    public static Grid Square(this Grid raster) => sa.Square(raster);
    public static Grid SquareRoot(this Grid raster) => sa.SquareRoot(raster);
    public static Grid Times(this Grid raster1, Grid raster2) => sa.Times(raster1, raster2);
    public static Grid Times(this Grid raster, int n) => sa.Times(raster, n);
    public static Grid Times(this Grid raster, double n) => sa.Times(raster, n);
    public static Grid BitwiseAnd(this Grid raster1, Grid raster2) => sa.BitwiseAnd(raster1, raster2);
    public static Grid BitwiseAnd(this Grid raster, int n) => sa.BitwiseAnd(raster, n);
    public static Grid BitwiseAnd(this Grid raster, double n) => sa.BitwiseAnd(raster, n);
    public static Grid BitwiseLeftShift(this Grid raster1, Grid raster2) => sa.BitwiseLeftShift(raster1, raster2);
    public static Grid BitwiseLeftShift(this Grid raster, int n) => sa.BitwiseLeftShift(raster, n);
    public static Grid BitwiseLeftShift(this Grid raster, double n) => sa.BitwiseLeftShift(raster, n);
    public static Grid BitwiseNot(this Grid raster) => sa.BitwiseNot(raster);
    public static Grid BitwiseOr(this Grid raster1, Grid raster2) => sa.BitwiseOr(raster1, raster2);
    public static Grid BitwiseOr(this Grid raster, int n) => sa.BitwiseOr(raster, n);
    public static Grid BitwiseOr(this Grid raster, double n) => sa.BitwiseOr(raster, n);
    public static Grid BitwiseRightShift(this Grid raster1, Grid raster2) => sa.BitwiseRightShift(raster1, raster2);
    public static Grid BitwiseRightShift(this Grid raster, int n) => sa.BitwiseRightShift(raster, n);
    public static Grid BitwiseRightShift(this Grid raster, double n) => sa.BitwiseRightShift(raster, n);
    public static Grid BitwiseXOr(this Grid raster1, Grid raster2) => sa.BitwiseXOr(raster1, raster2);
    public static Grid BitwiseXOr(this Grid raster, int n) => sa.BitwiseXOr(raster, n);
    public static Grid BitwiseXOr(this Grid raster, double n) => sa.BitwiseXOr(raster, n);
    public static Grid BooleanAnd(this Grid raster1, Grid raster2) => sa.BooleanAnd(raster1, raster2);
    public static Grid BooleanAnd(this Grid raster, int n) => sa.BooleanAnd(raster, n);
    public static Grid BooleanAnd(this Grid raster, double n) => sa.BooleanAnd(raster, n);
    public static Grid BooleanNot(this Grid raster) => sa.BooleanNot(raster);
    public static Grid BooleanOr(this Grid raster1, Grid raster2) => sa.BooleanOr(raster1, raster2);
    public static Grid BooleanOr(this Grid raster, int n) => sa.BooleanOr(raster, n);
    public static Grid BooleanOr(this Grid raster, double n) => sa.BooleanOr(raster, n);
    public static Grid BooleanXOr(this Grid raster1, Grid raster2) => sa.BooleanXOr(raster1, raster2);
    public static Grid BooleanXOr(this Grid raster, int n) => sa.BooleanXOr(raster, n);
    public static Grid BooleanXOr(this Grid raster, double n) => sa.BooleanXOr(raster, n);
    public static Grid CombinatorialAnd(this Grid raster1, Grid raster2) => sa.CombinatorialAnd(raster1, raster2);
    public static Grid CombinatorialAnd(this Grid raster, int n) => sa.CombinatorialAnd(raster, n);
    public static Grid CombinatorialOr(this Grid raster1, Grid raster2) => sa.CombinatorialOr(raster1, raster2);
    public static Grid CombinatorialOr(this Grid raster, int n) => sa.CombinatorialOr(raster, n);
    public static Grid CombinatorialXOr(this Grid raster1, Grid raster2) => sa.CombinatorialXOr(raster1, raster2);
    public static Grid CombinatorialXOr(this Grid raster, int n) => sa.CombinatorialXOr(raster, n);
    public static Grid Diff(this Grid raster1, Grid raster2) => sa.Diff(raster1, raster2);
    public static Grid Diff(this Grid raster, int n) => sa.Diff(raster, n);
    public static Grid Diff(this Grid raster, double n) => sa.Diff(raster, n);
    public static Grid EqualTo(this Grid raster1, Grid raster2) => sa.EqualTo(raster1, raster2);
    public static Grid EqualTo(this Grid raster, int n) => sa.EqualTo(raster, n);
    public static Grid EqualTo(this Grid raster, double n) => sa.EqualTo(raster, n);
    public static Grid GreaterThan(this Grid raster1, Grid raster2) => sa.GreaterThan(raster1, raster2);
    public static Grid GreaterThan(this Grid raster, int n) => sa.GreaterThan(raster, n);
    public static Grid GreaterThan(this Grid raster, double n) => sa.GreaterThan(raster, n);
    public static Grid GreaterThanEqual(this Grid raster1, Grid raster2) => sa.GreaterThanEqual(raster1, raster2);
    public static Grid GreaterThanEqual(this Grid raster, int n) => sa.GreaterThanEqual(raster, n);
    public static Grid GreaterThanEqual(this Grid raster, double n) => sa.GreaterThanEqual(raster, n);
    public static Grid InList(this Grid raster, params Grid[] list) => sa.InList(raster, list);
    public static Grid InList(this Grid raster, params int[] list) => sa.InList(raster, list);
    public static Grid InList(this Grid raster, params double[] list) => sa.InList(raster, list);
    public static Grid IsNull(this Grid raster) => sa.IsNull(raster);
    public static Grid LessThan(this Grid raster1, Grid raster2) => sa.LessThan(raster1, raster2);
    public static Grid LessThan(this Grid raster, int n) => sa.LessThan(raster, n);
    public static Grid LessThan(this Grid raster, double n) => sa.LessThan(raster, n);
    public static Grid LessThanEqual(this Grid raster1, Grid raster2) => sa.LessThanEqual(raster1, raster2);
    public static Grid LessThanEqual(this Grid raster, int n) => sa.LessThanEqual(raster, n);
    public static Grid LessThanEqual(this Grid raster, double n) => sa.LessThanEqual(raster, n);
    public static Grid NotEqual(this Grid raster1, Grid raster2) => sa.NotEqual(raster1, raster2);
    public static Grid NotEqual(this Grid raster, int n) => sa.NotEqual(raster, n);
    public static Grid NotEqual(this Grid raster, double n) => sa.NotEqual(raster, n);
    public static Grid Over(this Grid raster1, Grid raster2) => sa.Over(raster1, raster2);
    public static Grid Over(this Grid raster, int n) => sa.Over(raster, n);
    public static Grid Over(this Grid raster, double n) => sa.Over(raster, n);
    public static Grid Test(this Grid raster, string whereClause) => sa.Test(raster, whereClause);
    public static Grid ACos(this Grid raster) => sa.ACos(raster);
    public static Grid ACosH(this Grid raster) => sa.ACosH(raster);
    public static Grid ASin(this Grid raster) => sa.ASin(raster);
    public static Grid ASinH(this Grid raster) => sa.ASinH(raster);
    public static Grid ATan(this Grid raster) => sa.ATan(raster);
    public static Grid ATan2(this Grid raster1, Grid raster2) => sa.ATan2(raster1, raster2);
    public static Grid ATan2(this Grid raster, int n) => sa.ATan2(raster, n);
    public static Grid ATan2(this Grid raster, double n) => sa.ATan2(raster, n);
    public static Grid ATanH(this Grid raster) => sa.ATanH(raster);
    public static Grid Cos(this Grid raster) => sa.Cos(raster);
    public static Grid CosH(this Grid raster) => sa.CosH(raster);
    public static Grid Sin(this Grid raster) => sa.Sin(raster);
    public static Grid SinH(this Grid raster) => sa.SinH(raster);
    public static Grid Tan(this Grid raster) => sa.Tan(raster);
    public static Grid TanH(this Grid raster) => sa.TanH(raster);
    public static Grid BlockStatistics(this Grid inRaster, Nbr? neighborhood = null, StatisticsType statisticsType = StatisticsType.Mean, MissingValues ignoreNodata = MissingValues.Data) => sa.BlockStatistics(inRaster, neighborhood, statisticsType, ignoreNodata);
    public static Grid Filter(this Grid inRaster, FilterType filterType = FilterType.Low, MissingValues ignoreNodata = MissingValues.Data) => sa.Filter(inRaster, filterType, ignoreNodata);
    public static Grid FocalFlow(this Grid inSurfaceRaster, double? thresholdValue = null) => sa.FocalFlow(inSurfaceRaster, thresholdValue);
    public static Grid FocalStatistics(this Grid inRaster, Nbr neighborhood, StatisticsType statisticsType = StatisticsType.Mean, MissingValues ignoreNodata = MissingValues.Data) => sa.FocalStatistics(inRaster, neighborhood, statisticsType, ignoreNodata);
    public static Grid FuzzyMembership(this Grid inRaster, Fuzzy? fuzzyFunction = null, string? hedge = null) => sa.FuzzyMembership(inRaster, fuzzyFunction, hedge);
    public static Grid Lookup(this Grid inRaster, string lookupField) => sa.Lookup(inRaster, lookupField);
    public static Grid ReclassByASCIIFile(this Grid inRaster, FilePath inRemapFile, MissingValues missingValues = MissingValues.Data) => sa.ReclassByASCIIFile(inRaster, inRemapFile, missingValues);
    public static Grid ReclassByTable(this Grid inRaster, FilePath inRemapTable, string fromValueField, string toValueField, string outputValueField, MissingValues missingValues = MissingValues.Data) => sa.ReclassByTable(inRaster, inRemapTable, fromValueField, toValueField, outputValueField, missingValues);
    public static Grid Reclassify(this Grid inRaster, string reclassField, Remap remap, MissingValues missingValues = MissingValues.Data) => sa.Reclassify(inRaster, reclassField, remap, missingValues);
    public static Grid RescaleByFunction(this Grid inRaster, Tf? transformationFunction = null, double fromScale = 1, double toScale = 10) => sa.RescaleByFunction(inRaster, transformationFunction, fromScale, toScale);
    public static Grid Slice(this Grid inRaster, int numberZones, SliceType sliceType = SliceType.EqualInterval, int baseOutputZone = 1) => sa.Slice(inRaster, numberZones, sliceType, baseOutputZone);
    public static Grid ClassifyRaster(this Grid inRaster, FilePath inClassifierDefinition, Grid? inAdditionalGrid = null) => sa.ClassifyRaster(inRaster, inClassifierDefinition, inAdditionalGrid);
    public static Grid ComputeSegmentAttributes(this Grid inSegmentedRaster, Grid? inAdditionalGrid = null, string? usedAttributes = null) => sa.ComputeSegmentAttributes(inSegmentedRaster, inAdditionalGrid, usedAttributes);
    public static Grid InspectTrainingSamples(this Grid inRaster, FilePath inTrainingFeatures, FilePath inClassifierDefinition, FilePath outTrainingFeatureClass, Grid? inAdditionalGrid = null) => sa.InspectTrainingSamples(inRaster, inTrainingFeatures, inClassifierDefinition, outTrainingFeatureClass, inAdditionalGrid);
    public static Grid RemoveRasterSegmentTilingArtifacts(this Grid inSegmentedRaster, int tileSizeX = 512, int tileSizeY = 512) => sa.RemoveRasterSegmentTilingArtifacts(inSegmentedRaster, tileSizeX, tileSizeY);
    public static Grid SegmentMeanShift(this Grid inRaster, double? spectralDetail = null, double? spatialDetail = null, int? minSegmentSize = null, string? bandIndexes = null) => sa.SegmentMeanShift(inRaster, spectralDetail, spatialDetail, minSegmentSize, bandIndexes);
    public static Grid Aspect(this Grid inRaster, bool geodesic = false, ZUnit zUnit = ZUnit.Meter) => sa.Aspect(inRaster, geodesic, zUnit);
    public static Grid Curvature(this Grid inRaster, double zFactor = 1, Grid? outProfileCurveGrid = null, FilePath? outPlanCurveGrid = null) => sa.Curvature(inRaster, zFactor, outProfileCurveGrid, outPlanCurveGrid);
    public static Grid CutFill(this Grid inBeforeSurface, Grid inAfterSurface, double zFactor = 1) => sa.CutFill(inBeforeSurface, inAfterSurface, zFactor);
    public static Grid Hillshade(this Grid inRaster, double azimuth = 315, double altitude = 45, bool modelShadows = false, double zFactor = 1) => sa.Hillshade(inRaster, azimuth, altitude, modelShadows, zFactor);
    public static Grid ObserverPoints(this Grid inRaster, FilePath inObserverPointFeatures, double zFactor = 1, bool curvatureCorrection = false, double refractivityCoefficient = 0.13, FilePath? outAglGrid = null) => sa.ObserverPoints(inRaster, inObserverPointFeatures, zFactor, curvatureCorrection, refractivityCoefficient, outAglGrid);
    public static Grid Slope(this Grid inRaster, SlopeMeasurement outputMeasurement = SlopeMeasurement.Degree, double zFactor = 1, bool geodesic = false, ZUnit zUnit = ZUnit.Meter) => sa.Slope(inRaster, outputMeasurement, zFactor, geodesic, zUnit);
    public static Grid Viewshed(this Grid inRaster, FilePath inObserverFeatures, double zFactor = 1, bool? curvatureCorrection = null, double? refractivityCoefficient = null, FilePath? outAglGrid = null) => sa.Viewshed(inRaster, inObserverFeatures, zFactor, curvatureCorrection, refractivityCoefficient, outAglGrid);
    public static Grid ZonalFill(this Grid inZoneGrid, Grid inWeightGrid) => sa.ZonalFill(inZoneGrid, inWeightGrid);
    public static Grid ZonalGeometry(this Grid inZoneData, string zoneField, string? geometryType = null, double? cellSize = null) => sa.ZonalGeometry(inZoneData, zoneField, geometryType, cellSize);
    public static Grid ZonalStatistics(this Grid inZoneData, string zoneField, Grid inValueGrid, string? statisticsType = null, MissingValues ignoreNodata = MissingValues.Data) => sa.ZonalStatistics(inZoneData, zoneField, inValueGrid, statisticsType, ignoreNodata);
}
